/Users/prashanthboovaragavan/Documents/workspace/privateLLM/graph-rag-backend/scripts/test_25step_graphrag.py:1345: DeprecationWarning: `search` method is deprecated and will be removed in the future. Use `query_points` instead.
  results = qdrant.search(

======================================================================
  25-Step CI/CD Pipeline GraphRAG Test
======================================================================

Demonstrates:
  â€¢ Complex 25-step workflow with 4 modules
  â€¢ Real OpenAI embeddings for semantic search
  â€¢ Graph traversal for execution flow analysis
  â€¢ LLM-powered code explanation
  â€¢ Cross-module dependency tracking
======================================================================

======================================================================
  1. Ingesting 25-Step Pipeline Code
======================================================================
======================================================================
  Ingesting 25-Step CI/CD Pipeline
======================================================================

  Initializing clients...

  Creating Qdrant collection with 1536D vectors...

  Processing orchestrator.py...
    Neo4j: 34 nodes, 32 relationships
    Qdrant: 34 embeddings created

  Processing security.py...
    Neo4j: 29 nodes, 24 relationships
    Qdrant: 29 embeddings created

  Processing deployment.py...
    Neo4j: 31 nodes, 27 relationships
    Qdrant: 31 embeddings created

  Processing monitoring.py...
    Neo4j: 25 nodes, 21 relationships
    Qdrant: 25 embeddings created

  Uploading 119 embeddings to Qdrant...
    Uploaded batch 1/2
    Uploaded batch 2/2

  âœ“ Total: 119 nodes, 104 relationships in Neo4j
  âœ“ Total: 119 real embeddings in Qdrant

----------------------------------------------------------------------
  Semantic Search Tests
----------------------------------------------------------------------

  Query: "How does the system scan for security vulnerabilities?"
  Step 1: Creating query embedding...
  Step 2: Searching for semantically similar code...

  Found 5 relevant code segments:

    1. step_05_scan_dependencies (Method) - Similarity: 0.568
       File: orchestrator.py
       Step 5: Scan dependencies for known vulnerabilities....
    2. DependencyScanner (Class) - Similarity: 0.566
       File: security.py
       Scans project dependencies for known vulnerabilities. Used in Step 5 of the pipe...
    3. scan_dependencies (Method) - Similarity: 0.560
       File: security.py
       Scan all project dependencies against vulnerability databases.  Checks: - NPM pa...
    4. _scan_docker_images (Method) - Similarity: 0.492
       File: security.py
       Scan Docker image vulnerabilities....
    5. _scan_npm_dependencies (Method) - Similarity: 0.473
       File: security.py
       Scan NPM dependencies....

  Step 3: Using LLM to generate comprehensive answer...

  ==================================================================
  LLM Answer:
  ==================================================================
  The system scans for security vulnerabilities by analyzing project dependencies against various vulnerability databases. It conducts checks on different types of dependencies, including:
  
  - NPM packages, using `npm audit`
  - Python packages, using tools like `safety` and `pip-audit`
  - Docker base images
  - System libraries
  
  These checks are performed by the `DependencyScanner` class within the `security.py` file, specifically through its `scan_dependencies` method. This method aggregates vulnerabilities found across different dependency types, including NPM dependencies and Docker images, as indicated by the presence of dedicated scanning methods (`_scan_npm_dependencies` and `_scan_docker_images`). However, the specific implementation details of how each type of dependency is scanned (beyond the tools mentioned for NPM and Python packages) and how vulnerabilities are aggregated and returned are not provided in the given code excerpts.
  ==================================================================

  Query: "What deployment strategies are supported?"
  Step 1: Creating query embedding...
  Step 2: Searching for semantically similar code...

  Found 5 relevant code segments:

    1. DeploymentStrategy (Class) - Similarity: 0.566
       File: deployment.py
       Deployment strategy types....
    2. ProductionDeployer (Class) - Similarity: 0.492
       File: deployment.py
       Deploys application to production with advanced strategies. Used in Step 21 of t...
    3. __init__ (Method) - Similarity: 0.419
       File: deployment.py
    4. deployment (Module) - Similarity: 0.407
       File: deployment.py
       Deployment Module - Handles deployment to staging and production Implements step...
    5. deploy_with_canary (Method) - Similarity: 0.384
       File: deployment.py
       Deploy using canary deployment strategy.  Canary Deployment Process: 1. Deploy n...

  Step 3: Using LLM to generate comprehensive answer...

  ==================================================================
  LLM Answer:
  ==================================================================
  The supported deployment strategies are:
  
  1. Blue-Green
  2. Canary
  3. Rolling
  4. Recreate
  ==================================================================

  Query: "How is monitoring and alerting configured?"
  Step 1: Creating query embedding...
  Step 2: Searching for semantically similar code...

  Found 5 relevant code segments:

    1. step_25_enable_alerting (Method) - Similarity: 0.508
       File: orchestrator.py
       Step 25: Enable alerting and incident management....
    2. step_24_setup_monitoring (Method) - Similarity: 0.497
       File: orchestrator.py
       Step 24: Configure monitoring and observability....
    3. _configure_high_priority_alerts (Method) - Similarity: 0.489
       File: monitoring.py
       Configure high priority alerts....
    4. _configure_medium_priority_alerts (Method) - Similarity: 0.487
       File: monitoring.py
       Configure medium priority alerts....
    5. setup_alerts (Method) - Similarity: 0.482
       File: monitoring.py
       Configure alerting rules and incident management.  Alert Categories: - Critical:...

  Step 3: Using LLM to generate comprehensive answer...

  ==================================================================
  LLM Answer:
  ==================================================================
  Monitoring and alerting in the system are configured through a multi-step process, as outlined in the provided code snippets from `orchestrator.py` and `monitoring.py`. Here's a breakdown of how the configuration is structured:
  
  1. **Monitoring Setup (`step_24_setup_monitoring` in `orchestrator.py`):**
     - This step is responsible for setting up monitoring and observability infrastructure. Although the code snippet is incomplete, it indicates the initiation of monitoring setup by importing and utilizing a `MonitoringSetup` class from a monitoring module. This likely involves configuring metrics collection, dashboards for observability, and possibly integrating with existing monitoring tools or services.
  
  2. **Alerting Setup (`step_25_enable_alerting` in `orchestrator.py`):**
     - Following the monitoring setup, the next step involves enabling alerting and incident management. This is done by importing and creating an instance of `AlertManager` from a monitoring module. The process likely involves configuring alerting rules based on the monitoring data collected in the previous step. The incomplete code snippet suggests that alert configurations are being set up but does not detail how these configurations are applied.
  
  3. **Alert Configuration (`setup_alerts` in `monitoring.py`):**
     - The `setup_alerts` function outlines the framework for configuring alerting rules and incident management based on various metrics such as high error rates, slow response times, high CPU/memory usage, failed health checks, security incidents,
  ==================================================================

  Query: "What happens in the blue-green deployment process?"
  Step 1: Creating query embedding...
  Step 2: Searching for semantically similar code...

  Found 5 relevant code segments:

    1. deploy_with_blue_green (Method) - Similarity: 0.573
       File: deployment.py
       Deploy to production using blue-green deployment strategy.  Blue-Green Deploymen...
    2. __init__ (Method) - Similarity: 0.519
       File: deployment.py
    3. DeploymentStrategy (Class) - Similarity: 0.456
       File: deployment.py
       Deployment strategy types....
    4. step_19_deploy_to_staging (Method) - Similarity: 0.425
       File: orchestrator.py
       Step 19: Deploy application to staging environment....
    5. step_21_deploy_to_production (Method) - Similarity: 0.422
       File: orchestrator.py
       Step 21: Deploy application to production environment....

  Step 3: Using LLM to generate comprehensive answer...

  ==================================================================
  LLM Answer:
  ==================================================================
  In the blue-green deployment process, the following steps are taken:
  
  1. Deploy the application to an inactive (green) environment.
  2. Run smoke tests on the green environment to ensure the new deployment works as expected.
  3. Switch traffic from the active (blue) environment to the green environment, making the green environment the new production environment.
  4. Monitor the green environment for any errors to ensure stability and performance.
  5. Keep the blue environment without directing traffic to it, allowing for a quick rollback if necessary.
  6. After the green environment has been validated and deemed stable, decommission the blue environment.
  ==================================================================

----------------------------------------------------------------------
  Flow-Based Graph Traversal Tests
----------------------------------------------------------------------

  Query: Trace the complete execution flow of the 25-step pipeline

  Step 1: Finding pipeline entry point...
    âœ“ Found: execute_pipeline()
    Execute the complete 25-step CI/CD pipeline.

Args:
    code_repo: Repository URL or path
    branch...

  Step 2: Finding all 25 pipeline steps...
    âœ“ Found 50 pipeline steps:

      Step 01: Step 1: Checkout code from version control.
      Step 01: Step 1: Checkout code from version control.
      Step 02: Step 2: Validate code syntax across all files.
      Step 02: Step 2: Validate code syntax across all files.
      Step 03: Step 3: Run code linting and style checks.
      Step 03: Step 3: Run code linting and style checks.
      Step 04: Step 4: Scan for exposed secrets and credentials.
      Step 04: Step 4: Scan for exposed secrets and credentials.
      Step 05: Step 5: Scan dependencies for known vulnerabilities.
      Step 05: Step 5: Scan dependencies for known vulnerabilities.
      ... and 40 more steps

  Step 3: Finding cross-module dependencies...
    âœ“ Found 0 cross-module dependencies:


  Step 4: Generating LLM-powered workflow explanation...

  ==================================================================
  LLM-Generated Pipeline Overview:
  ==================================================================
  The provided 25-step CI/CD pipeline can be analyzed and broken down into distinct phases, each serving a specific purpose in the software development lifecycle. This pipeline is designed to automate the process of integrating code changes, validating them, and deploying them to production environments. Here's a comprehensive overview of how this pipeline works, organized by phases:
  
  ### Phase 1: Code Validation (Steps 1-3)
  - **Step 1: Checkout Code from Version Control** - The process begins by pulling the latest code from the specified branch of the repository. This ensures that all subsequent steps are performed on the most current version of the codebase.
  - **Step 2: Validate Code Syntax Across All Files** - This step involves checking the syntax of the code across all files to catch any syntax errors early in the development process.
  - **Step 3: Run Code Linting and Style Checks** - Linting tools are used to analyze the code for potential errors, code smells, and to enforce a consistent coding style. This helps maintain code quality and readability.
  
  ### Phase 2: Security and Compliance (Steps 4-7)
  - **Step 4: Scan for Exposed Secrets and Credentials** - Scans the codebase for accidentally committed secrets like passwords, API keys, and tokens to prevent security breaches.
  - **Step 5: Scan Dependencies for Known Vulnerabilities** - Checks all project dependencies against vulnerability databases to identify and mitigate known security issues.
  - **Step 6: Check License Compliance for All Dependencies** - Ensures that the licenses of all dependencies are compatible with the project's license and comply with legal requirements.
  - **Step 7: Static Application Security Testing (SAST)** - Analyzes the source code for security vulnerabilities without executing it, identifying potential security threats.
  
  ### Phase 3: Build and Dependency Management (Steps 8-10)
  - **Step 8: Install All Project Dependencies** - Installs the necessary libraries and dependencies required for the project to run.
  - **Step 9: Compile Source Code to Executable Form** - Transforms the source code into executable binaries or byte code, making it ready for deployment or testing.
  - **Step 10: Generate Static Assets and Resources** - Processes and generates static resources such as images, stylesheets, and scripts that are required for the application to run.
  
  ### Phase 4: Testing (Steps 11-13)
  - **Step 11: Execute Unit Test Suite** - Runs the unit tests to validate the functionality of individual components or functions in isolation.
  - **Step 12: Execute Integration Test Suite** - Performs integration tests to ensure that different parts of the application work together as expected.
  - **Step 13: Execute End-to-End Test Suite** - Conducts end-to-end tests to verify the complete flow of the application from start to finish, simulating real-user scenarios.
  
  ### Phase 5: Deployment and Delivery (Assuming Steps 14-
  ==================================================================

======================================================================
  Cleanup
======================================================================
  âœ“ Cleaned up Neo4j test data
  âœ“ Deleted Qdrant collection 'pipeline_25step_code'

======================================================================
  âœ“ 25-Step GraphRAG Test Complete!
======================================================================

ðŸ’¡ Key Capabilities Demonstrated:
  â€¢ Ingested 4 modules with 25+ distinct pipeline steps
  â€¢ Semantic search found relevant code with high accuracy
  â€¢ Graph traversal successfully traced execution flows
  â€¢ LLM generated comprehensive workflow explanations
  â€¢ Cross-module dependencies correctly identified

Your FlowRAG system handles complex workflows excellently!
